{"version":3,"file":"js/a40fe077d67da77c1114.js","mappings":"uKAGe,SAASA,EAAW,CACjC,OAAAC,EACA,aAAAC,EACA,GAAAC,EACA,KAAAC,CACF,EAAG,CACD,MAAMC,KAAS,MAAU,EACzBH,EAAa,CACX,WAAY,CACV,QAAS,GACT,eAAgB,GAChB,OAAQ,GACR,YAAa,GACb,YAAa,EACb,aAAc,YACd,eAAgB,KAChB,cAAe,IACjB,CACF,CAAC,EACDD,EAAO,WAAa,CAClB,QAAS,EACX,EACA,IAAIK,EACAC,KAAiB,MAAI,EACrBC,EACJ,MAAMC,EAAoB,CAAC,EAC3B,SAASC,EAAUC,EAAG,CAKpB,IAAIC,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EAGT,MAAI,WAAYJ,IACdE,EAAKF,EAAE,QAEL,eAAgBA,IAClBE,EAAK,CAACF,EAAE,WAAa,KAEnB,gBAAiBA,IACnBE,EAAK,CAACF,EAAE,YAAc,KAEpB,gBAAiBA,IACnBC,EAAK,CAACD,EAAE,YAAc,KAIpB,SAAUA,GAAKA,EAAE,OAASA,EAAE,kBAC9BC,EAAKC,EACLA,EAAK,GAEPC,EAAKF,EAAK,GACVG,EAAKF,EAAK,GACN,WAAYF,IACdI,EAAKJ,EAAE,QAEL,WAAYA,IACdG,EAAKH,EAAE,QAELA,EAAE,UAAY,CAACG,IAEjBA,EAAKC,EACLA,EAAK,IAEFD,GAAMC,IAAOJ,EAAE,YACdA,EAAE,YAAc,GAElBG,GAAM,GACNC,GAAM,KAGND,GAAM,IACNC,GAAM,MAKND,GAAM,CAACF,IACTA,EAAKE,EAAK,EAAI,GAAK,GAEjBC,GAAM,CAACF,IACTA,EAAKE,EAAK,EAAI,GAAK,GAEd,CACL,MAAOH,EACP,MAAOC,EACP,OAAQC,EACR,OAAQC,CACV,CACF,CACA,SAASC,GAAmB,CACrBf,EAAO,UACZA,EAAO,aAAe,GACxB,CACA,SAASgB,GAAmB,CACrBhB,EAAO,UACZA,EAAO,aAAe,GACxB,CACA,SAASiB,EAAcC,EAAU,CAK/B,OAJIlB,EAAO,OAAO,WAAW,gBAAkBkB,EAAS,MAAQlB,EAAO,OAAO,WAAW,gBAIrFA,EAAO,OAAO,WAAW,kBAAiB,MAAI,EAAIM,EAAiBN,EAAO,OAAO,WAAW,cAEvF,GAMLkB,EAAS,OAAS,MAAK,MAAI,EAAIZ,EAAiB,GAE3C,IAcLY,EAAS,UAAY,GAClB,CAAClB,EAAO,OAASA,EAAO,OAAO,OAAS,CAACA,EAAO,YACnDA,EAAO,UAAU,EACjBG,EAAK,SAAUe,EAAS,GAAG,IAEnB,CAAClB,EAAO,aAAeA,EAAO,OAAO,OAAS,CAACA,EAAO,YAChEA,EAAO,UAAU,EACjBG,EAAK,SAAUe,EAAS,GAAG,GAG7BZ,EAAiB,IAAIF,EAAO,KAAK,EAAE,QAAQ,EAEpC,GACT,CACA,SAASe,EAAcD,EAAU,CAC/B,MAAME,EAASpB,EAAO,OAAO,WAC7B,GAAIkB,EAAS,UAAY,GACvB,GAAIlB,EAAO,OAAS,CAACA,EAAO,OAAO,MAAQoB,EAAO,eAEhD,MAAO,WAEApB,EAAO,aAAe,CAACA,EAAO,OAAO,MAAQoB,EAAO,eAE7D,MAAO,GAET,MAAO,EACT,CACA,SAASC,EAAOC,EAAO,CACrB,IAAIZ,EAAIY,EACJC,EAAsB,GAC1B,GAAI,CAACvB,EAAO,QAAS,OACrB,MAAMoB,EAASpB,EAAO,OAAO,WACzBA,EAAO,OAAO,SAChBU,EAAE,eAAe,EAEnB,IAAIc,EAAWxB,EAAO,GAClBA,EAAO,OAAO,WAAW,eAAiB,cAC5CwB,EAAW,SAAS,cAAcxB,EAAO,OAAO,WAAW,YAAY,GAEzE,MAAMyB,EAAyBD,GAAYA,EAAS,SAASd,EAAE,MAAM,EACrE,GAAI,CAACV,EAAO,cAAgB,CAACyB,GAA0B,CAACL,EAAO,eAAgB,MAAO,GAClFV,EAAE,gBAAeA,EAAIA,EAAE,eAC3B,IAAIgB,EAAQ,EACZ,MAAMC,EAAY3B,EAAO,aAAe,GAAK,EACvC4B,EAAOnB,EAAUC,CAAC,EACxB,GAAIU,EAAO,YACT,GAAIpB,EAAO,aAAa,EACtB,GAAI,KAAK,IAAI4B,EAAK,MAAM,EAAI,KAAK,IAAIA,EAAK,MAAM,EAAGF,EAAQ,CAACE,EAAK,OAASD,MAAe,OAAO,WACvF,KAAK,IAAIC,EAAK,MAAM,EAAI,KAAK,IAAIA,EAAK,MAAM,EAAGF,EAAQ,CAACE,EAAK,WAAY,OAAO,QAE3FF,EAAQ,KAAK,IAAIE,EAAK,MAAM,EAAI,KAAK,IAAIA,EAAK,MAAM,EAAI,CAACA,EAAK,OAASD,EAAY,CAACC,EAAK,OAE3F,GAAIF,IAAU,EAAG,MAAO,GACpBN,EAAO,SAAQM,EAAQ,CAACA,GAG5B,IAAIG,EAAY7B,EAAO,aAAa,EAAI0B,EAAQN,EAAO,YAavD,GAZIS,GAAa7B,EAAO,aAAa,IAAG6B,EAAY7B,EAAO,aAAa,GACpE6B,GAAa7B,EAAO,aAAa,IAAG6B,EAAY7B,EAAO,aAAa,GASxEuB,EAAsBvB,EAAO,OAAO,KAAO,GAAO,EAAE6B,IAAc7B,EAAO,aAAa,GAAK6B,IAAc7B,EAAO,aAAa,GACzHuB,GAAuBvB,EAAO,OAAO,QAAQU,EAAE,gBAAgB,EAC/D,CAACV,EAAO,OAAO,UAAY,CAACA,EAAO,OAAO,SAAS,QAAS,CAE9D,MAAMkB,EAAW,CACf,QAAM,MAAI,EACV,MAAO,KAAK,IAAIQ,CAAK,EACrB,UAAW,KAAK,KAAKA,CAAK,EAC1B,IAAKJ,CACP,EAGId,EAAkB,QAAU,GAC9BA,EAAkB,MAAM,EAG1B,MAAMsB,EAAYtB,EAAkB,OAASA,EAAkBA,EAAkB,OAAS,CAAC,EAAI,OAmB/F,GAlBAA,EAAkB,KAAKU,CAAQ,EAQ3BY,GACEZ,EAAS,YAAcY,EAAU,WAAaZ,EAAS,MAAQY,EAAU,OAASZ,EAAS,KAAOY,EAAU,KAAO,MACrHb,EAAcC,CAAQ,EAGxBD,EAAcC,CAAQ,EAKpBC,EAAcD,CAAQ,EACxB,MAAO,EAEX,KAAO,CAOL,MAAMA,EAAW,CACf,QAAM,MAAI,EACV,MAAO,KAAK,IAAIQ,CAAK,EACrB,UAAW,KAAK,KAAKA,CAAK,CAC5B,EACMK,EAAoBxB,GAAuBW,EAAS,KAAOX,EAAoB,KAAO,KAAOW,EAAS,OAASX,EAAoB,OAASW,EAAS,YAAcX,EAAoB,UAC7L,GAAI,CAACwB,EAAmB,CACtBxB,EAAsB,OACtB,IAAIyB,EAAWhC,EAAO,aAAa,EAAI0B,EAAQN,EAAO,YACtD,MAAMa,EAAejC,EAAO,YACtBkC,EAASlC,EAAO,MAiBtB,GAhBIgC,GAAYhC,EAAO,aAAa,IAAGgC,EAAWhC,EAAO,aAAa,GAClEgC,GAAYhC,EAAO,aAAa,IAAGgC,EAAWhC,EAAO,aAAa,GACtEA,EAAO,cAAc,CAAC,EACtBA,EAAO,aAAagC,CAAQ,EAC5BhC,EAAO,eAAe,EACtBA,EAAO,kBAAkB,EACzBA,EAAO,oBAAoB,GACvB,CAACiC,GAAgBjC,EAAO,aAAe,CAACkC,GAAUlC,EAAO,QAC3DA,EAAO,oBAAoB,EAEzBA,EAAO,OAAO,MAChBA,EAAO,QAAQ,CACb,UAAWkB,EAAS,UAAY,EAAI,OAAS,OAC7C,aAAc,EAChB,CAAC,EAEClB,EAAO,OAAO,SAAS,OAAQ,CAYjC,aAAaK,CAAO,EACpBA,EAAU,OACNG,EAAkB,QAAU,IAC9BA,EAAkB,MAAM,EAG1B,MAAMsB,EAAYtB,EAAkB,OAASA,EAAkBA,EAAkB,OAAS,CAAC,EAAI,OACzF2B,EAAa3B,EAAkB,CAAC,EAEtC,GADAA,EAAkB,KAAKU,CAAQ,EAC3BY,IAAcZ,EAAS,MAAQY,EAAU,OAASZ,EAAS,YAAcY,EAAU,WAErFtB,EAAkB,OAAO,CAAC,UACjBA,EAAkB,QAAU,IAAMU,EAAS,KAAOiB,EAAW,KAAO,KAAOA,EAAW,MAAQjB,EAAS,OAAS,GAAKA,EAAS,OAAS,EAAG,CAOnJ,MAAMkB,EAAkBV,EAAQ,EAAI,GAAM,GAC1CnB,EAAsBW,EACtBV,EAAkB,OAAO,CAAC,EAC1BH,KAAU,MAAS,IAAM,CACvBL,EAAO,eAAeA,EAAO,OAAO,MAAO,GAAM,OAAWoC,CAAe,CAC7E,EAAG,CAAC,CACN,CAEK/B,IAIHA,KAAU,MAAS,IAAM,CAEvBE,EAAsBW,EACtBV,EAAkB,OAAO,CAAC,EAC1BR,EAAO,eAAeA,EAAO,OAAO,MAAO,GAAM,OAAW,EAAe,CAC7E,EAAG,GAAG,EAEV,CAQA,GALK+B,GAAmB5B,EAAK,SAAUO,CAAC,EAGpCV,EAAO,OAAO,UAAYA,EAAO,OAAO,8BAA8BA,EAAO,SAAS,KAAK,EAE3FgC,IAAahC,EAAO,aAAa,GAAKgC,IAAahC,EAAO,aAAa,EAAG,MAAO,EACvF,CACF,CACA,OAAIU,EAAE,eAAgBA,EAAE,eAAe,EAAOA,EAAE,YAAc,GACvD,EACT,CACA,SAAS2B,EAAOC,EAAQ,CACtB,IAAId,EAAWxB,EAAO,GAClBA,EAAO,OAAO,WAAW,eAAiB,cAC5CwB,EAAW,SAAS,cAAcxB,EAAO,OAAO,WAAW,YAAY,GAEzEwB,EAASc,CAAM,EAAE,aAAcvB,CAAgB,EAC/CS,EAASc,CAAM,EAAE,aAActB,CAAgB,EAC/CQ,EAASc,CAAM,EAAE,QAASjB,CAAM,CAClC,CACA,SAASkB,GAAS,CAChB,OAAIvC,EAAO,OAAO,SAChBA,EAAO,UAAU,oBAAoB,QAASqB,CAAM,EAC7C,IAELrB,EAAO,WAAW,QAAgB,IACtCqC,EAAO,kBAAkB,EACzBrC,EAAO,WAAW,QAAU,GACrB,GACT,CACA,SAASwC,GAAU,CACjB,OAAIxC,EAAO,OAAO,SAChBA,EAAO,UAAU,iBAAiB,MAAOqB,CAAM,EACxC,IAEJrB,EAAO,WAAW,SACvBqC,EAAO,qBAAqB,EAC5BrC,EAAO,WAAW,QAAU,GACrB,IAHgC,EAIzC,CACAE,EAAG,OAAQ,IAAM,CACX,CAACF,EAAO,OAAO,WAAW,SAAWA,EAAO,OAAO,SACrDwC,EAAQ,EAENxC,EAAO,OAAO,WAAW,SAASuC,EAAO,CAC/C,CAAC,EACDrC,EAAG,UAAW,IAAM,CACdF,EAAO,OAAO,SAChBuC,EAAO,EAELvC,EAAO,WAAW,SAASwC,EAAQ,CACzC,CAAC,EACD,OAAO,OAAOxC,EAAO,WAAY,CAC/B,OAAAuC,EACA,QAAAC,CACF,CAAC,CACH,C","sources":["webpack://Falcon-theme/./node_modules/swiper/modules/mousewheel/mousewheel.js"],"sourcesContent":["/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}"],"names":["Mousewheel","swiper","extendParams","on","emit","window","timeout","lastScrollTime","lastEventBeforeSnap","recentWheelEvents","normalize","e","sX","sY","pX","pY","handleMouseEnter","handleMouseLeave","animateSlider","newEvent","releaseScroll","params","handle","event","disableParentSwiper","targetEl","targetElContainsTarget","delta","rtlFactor","data","positions","prevEvent","ignoreWheelEvents","position","wasBeginning","wasEnd","firstEvent","snapToThreshold","events","method","enable","disable"],"sourceRoot":""}